这是一份课程实验的需求（使用 <Lab> 和 </Lab> 标签标记），并据此编写了项目代码（使用 <Code> 和 </Code> 标签标记）：

<Lab>

## 输入处理要求
- 程序从文本文件读取英文文本数据
- 处理规则：
  - 所有换行符/回车符视为空格
  - 所有标点符号视为空格
  - 只保留A-Z和a-z字符，其他字符忽略
  - 单词不区分大小写（统一转为小写或大写处理）
  
**示例输入处理**：
```
输入文本：
To @ explore strange new worlds,
To seek out new life and new civilizations?

处理后等价于：
to explore strange new worlds to seek out new life and new civilizations
```

## 有向图构建要求
- 节点：文本中的每个唯一单词
- 边：当两个单词在文本中相邻出现时建立有向边
- 边权重：两个单词相邻出现的次数

**示例图构建**：
```
输入文本：
To explore strange new worlds to seek out new life and new civilizations

生成的有向图包含：
节点：to, explore, strange, new, worlds, seek, out, life, and, civilizations
边及其权重：
to→explore(1), explore→strange(1), strange→new(1), 
new→worlds(1), worlds→to(1), to→seek(1), 
seek→out(1), out→new(1), new→life(1), 
life→and(1), and→new(1), new→civilizations(1)
```

## 功能需求详解

### 1. 展示有向图
- 在命令行界面清晰展示图结构
- 展示格式应包含所有节点和边及其权重
- 可选：使用图形化方式保存有向图（如调用 Graphviz 等库）

### 2. 查询桥接词
- 输入：两个单词word1和word2
- 输出：
  - 如果word1或word2不在图中："No word1 or word2 in the graph!"
  - 如果没有桥接词："No bridge words from word1 to word2!"
  - 如果有桥接词："The bridge words from word1 to word2 are: xxx, xxx, and xxx."
  
**桥接词定义**：word3满足word1→word3和word3→word2两条边都存在

**示例测试用例**：
| word1  | word2    | 输出结果 |
|--------|----------|----------|
| seek   | to       | No bridge words from "seek" to "to"! |
| to     | explore  | No bridge words from "to" to "explore"! |
| explore | new     | The bridge words from "explore" to "new" is: "strange" |
| new    | and      | The bridge words from "new" to "and" is: "life" |
| and    | exciting | No "exciting" in the graph! |

### 3. 生成新文本
- 输入：一行新文本
- 处理：对新文本中每对相邻单词查询桥接词
  - 有桥接词：随机选择一个插入到两词之间
  - 无桥接词：保持不变
- 输出：插入桥接词后的新文本

**示例**：
```
输入：Seek to explore new and exciting synergies
输出：Seek to explore strange new life and exciting synergies
(插入"strange"作为"explore"和"new"的桥接词，
插入"life"作为"new"和"and"的桥接词)
```

### 4. 计算最短路径
- 输入：两个单词word1和word2
- 输出：
  - 不可达时提示
  - 可达时展示一条最短路径（边权和最小）及其长度
  - 可选：展示所有最短路径
  
**示例**：
```
输入：to 和 and
输出最短路径：
to→explore→strange→new→life→and
路径长度：5
```

### 5. 计算PageRank
- 实现标准PageRank算法
- 阻尼因子d固定为0.85
- 计算图中各节点的PR值
- 可选：改进初始PR值分配（如基于词频）

**PR计算公式**：
```
PR(A) = (1-d)/N + d * Σ(PR(Ti)/C(Ti))
其中：
- N是图中所有节点的数量
- Ti是指向A的节点
- C(Ti)是Ti的出链数量
- d=0.85
```

### 6. 随机游走
- 随机选择起点节点
- 随机选择出边进行遍历
- 停止条件：
  - 出现第一条重复的边，或
  - 到达无出边的节点
- 用户可随时手动停止
- 输出遍历路径并保存为文本文件

**示例输出**：
```
to seek out new life and new worlds to explore strange new civilizations
```

## 代码实现要求
- 必须使用Java实现
- 必须包含以下方法（不可改变签名）：

```java
public static void main(String[] args)  // 主程序入口
public static void showDirectedGraph(Object G, ...)  // 展示图
public static String queryBridgeWords(String word1, String word2)  // 查询桥接词
public static String generateNewText(String inputText)  // 生成新文本
public static String calcShortestPath(String word1, String word2)  // 计算最短路径
public static Double calcPageRank(String word)  // 计算PR值(d=0.85)
public static String randomWalk()  // 随机游走
```

## 其他要求
- 输入输出应集中在main方法中
- 不能使用第三方算法库（如JGraphT等）
- 可以使用基本数据结构和集合类
- 需要提供足够的测试用例验证正确性
- 使用Git进行版本管理

</Lab>

<Code name = "Graph.java">
import java.util.*;
import java.util.stream.Collectors;

public class Graph {
    private Map<String, Map<String, Integer>> adjacencyList;
    private Map<String, List<String>> inEdges;

    public Graph() {
        adjacencyList = new HashMap<>();
        inEdges = new HashMap<>();
    }

    public void addEdge(String from, String to) {
        adjacencyList.putIfAbsent(from, new HashMap<>());
        adjacencyList.get(from).put(to, adjacencyList.get(from).getOrDefault(to, 0) + 1);

        inEdges.putIfAbsent(to, new ArrayList<>());
        inEdges.get(to).add(from);
        adjacencyList.putIfAbsent(to, new HashMap<>());
    }

    public static Graph buildGraph(List<String> words) {
        Graph graph = new Graph();
        if (words.size() < 2) return graph;

        for (int i = 0; i < words.size() - 1; i++) {
            String from = words.get(i);
            String to = words.get(i + 1);
            graph.addEdge(from, to);
        }
        return graph;
    }

    public Set<String> getNodes() {
        return adjacencyList.keySet();
    }

    public Map<String, Integer> getEdges(String node) {
        return adjacencyList.getOrDefault(node, Collections.emptyMap());
    }

    public List<String> findBridgeWords(String word1, String word2) {
        if (!adjacencyList.containsKey(word1) || !adjacencyList.containsKey(word2)) return null;

        List<String> bridges = new ArrayList<>();
        Map<String, Integer> edgesFromWord1 = adjacencyList.get(word1);
        for (String candidate : edgesFromWord1.keySet()) {
            if (adjacencyList.get(candidate).containsKey(word2)) {
                bridges.add(candidate);
            }
        }
        return bridges;
    }

    public List<String> calcShortestPath(String start, String end) {
        if (!adjacencyList.containsKey(start) || !adjacencyList.containsKey(end)) return null;

        Map<String, Integer> distances = new HashMap<>();
        Map<String, String> predecessors = new HashMap<>();
        PriorityQueue<NodeDistance> queue = new PriorityQueue<>();

        adjacencyList.keySet().forEach(node -> distances.put(node, Integer.MAX_VALUE));
        distances.put(start, 0);
        queue.add(new NodeDistance(start, 0));

        while (!queue.isEmpty()) {
            NodeDistance current = queue.poll();
            if (current.distance > distances.get(current.node)) continue;

            adjacencyList.get(current.node).forEach((neighbor, weight) -> {
                int newDist = current.distance + weight;
                if (newDist < distances.get(neighbor)) {
                    distances.put(neighbor, newDist);
                    predecessors.put(neighbor, current.node);
                    queue.add(new NodeDistance(neighbor, newDist));
                }
            });
        }

        if (distances.get(end) == Integer.MAX_VALUE) return null;

        LinkedList<String> path = new LinkedList<>();
        String current = end;
        while (current != null) {
            path.addFirst(current);
            current = predecessors.get(current);
        }
        return path.getFirst().equals(start) ? path : null;
    }

    public Map<String, Double> calculatePageRank(int iterations) {
        int N = adjacencyList.size();
        if (N == 0) return new HashMap<>();

        // 使用数组包装来绕过 final 限制
        Map<String, Double>[] prWrapper = new Map[]{new HashMap<>()};
        double initial = 1.0 / N;
        adjacencyList.keySet().forEach(node -> prWrapper[0].put(node, initial));

        for (int i = 0; i < iterations; i++) {
            Map<String, Double> newPr = new HashMap<>();
            final Map<String, Double> currentPr = prWrapper[0]; // 创建 final 引用
            adjacencyList.keySet().forEach(node -> {
                double sum = inEdges.getOrDefault(node, Collections.emptyList()).stream()
                        .mapToDouble(inNode -> currentPr.get(inNode) / adjacencyList.get(inNode).size())
                        .sum();
                newPr.put(node, (1 - 0.85) / N + 0.85 * sum);
            });
            prWrapper[0] = newPr;
        }
    return prWrapper[0];
}

    public String randomWalk() {
        List<String> nodes = new ArrayList<>(adjacencyList.keySet());
        if (nodes.isEmpty()) return "";

        Random rand = new Random();
        String current = nodes.get(rand.nextInt(nodes.size()));
        List<String> path = new ArrayList<>();
        Set<String> visitedEdges = new HashSet<>();
        path.add(current);

        while (true) {
            Map<String, Integer> edges = adjacencyList.get(current);
            if (edges == null || edges.isEmpty()) break;

            List<String> candidates = new ArrayList<>(edges.keySet());
            String next = candidates.get(rand.nextInt(candidates.size()));
            String edge = current + "->" + next;

            if (visitedEdges.contains(edge)) break;
            visitedEdges.add(edge);

            path.add(next);
            current = next;
        }
        return String.join(" ", path);
    }

    private static class NodeDistance implements Comparable<NodeDistance> {
        String node;
        int distance;

        NodeDistance(String node, int distance) {
            this.node = node;
            this.distance = distance;
        }

        @Override
        public int compareTo(NodeDistance other) {
            return Integer.compare(this.distance, other.distance);
        }
    }
}
</Code>

<Code name = "TextProcessor.java">
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class TextProcessor {
    public static List<String> processText(String filePath) throws IOException {
        String content = Files.readString(Paths.get(filePath));
        content = content.replaceAll("[^a-zA-Z\\s]", " ")
                .toLowerCase()
                .replaceAll("\\s+", " ")
                .trim();
        if (content.isEmpty()) {
            return new ArrayList<>();
        }
        return Arrays.asList(content.split(" "));
    }
}
</Code>

<Code name = "Main.java">
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.*;
import java.util.stream.Collectors;

public class Main {
    private static Graph graph;

    public static void main(String[] args) {
        try {
            List<String> words = TextProcessor.processText("resources/input.txt");
            graph = Graph.buildGraph(words);

            Scanner scanner = new Scanner(System.in);
            while (true) {
                System.out.println("\nMenu Options:");
                System.out.println("1. Show Directed Graph");
                System.out.println("2. Query Bridge Words");
                System.out.println("3. Generate New Text");
                System.out.println("4. Calculate Shortest Path");
                System.out.println("5. Calculate PageRank");
                System.out.println("6. Random Walk");
                System.out.println("0. Exit");
                System.out.print("Please choose an option: ");
                int choice = scanner.nextInt();
                scanner.nextLine();

                switch (choice) {
                    case 1 -> showDirectedGraph(graph);
                    case 2 -> {
                        System.out.print("Enter two words (space separated): ");
                        String[] input = scanner.nextLine().trim().toLowerCase().split("\\s+");
                        if (input.length != 2) {
                            System.out.println("Invalid input!");
                            break;
                        }
                        System.out.println(queryBridgeWords(input[0], input[1]));
                    }
                    case 3 -> {
                        System.out.print("Enter new text: ");
                        String newText = generateNewText(scanner.nextLine());
                        System.out.println("Generated text: " + newText);
                    }
                    case 4 -> {
                        System.out.print("Enter two words (space separated): ");
                        String[] pathInput = scanner.nextLine().trim().toLowerCase().split("\\s+");
                        if (pathInput.length != 2) {
                            System.out.println("Invalid input!");
                            break;
                        }
                        System.out.println(calcShortestPath(pathInput[0], pathInput[1]));
                    }
                    case 5 -> {
                        System.out.print("Enter a word: ");
                        String word = scanner.nextLine().trim().toLowerCase();
                        System.out.println("PageRank value: " + calcPageRank(word));
                    }
                    case 6 -> {
                        String walk = randomWalk();
                        System.out.println("Random walk path: " + walk);
                        Files.write(Paths.get("random_walk.txt"), walk.getBytes());
                        System.out.println("Random walk saved to random_walk.txt");
                    }
                    case 0 -> {
                        scanner.close();
                        System.out.println("Exiting program...");
                        return;
                    }
                    default -> System.out.println("Invalid option");
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static void showDirectedGraph(Object G, String... args) {
        if (G instanceof Graph g) {
            System.out.println("Directed Graph Structure:");
            g.getNodes().forEach(node -> {
                String edges = g.getEdges(node).entrySet().stream()
                        .map(e -> e.getKey() + "(" + e.getValue() + ")")
                        .collect(Collectors.joining(", "));
                System.out.println(node + " -> " + (edges.isEmpty() ? "no outgoing edges" : edges));
            });
        }
    }

    public static String queryBridgeWords(String word1, String word2) {
        boolean hasWord1 = graph.getNodes().contains(word1);
        boolean hasWord2 = graph.getNodes().contains(word2);
        
        if (!hasWord1 && !hasWord2) {
            return "No \"" + word1 + "\" and \"" + word2 + "\" in the graph!";
        }
        if (!hasWord1) {
            return "No \"" + word1 + "\" in the graph!";
        }
        if (!hasWord2) {
            return "No \"" + word2 + "\" in the graph!";
        }

        List<String> bridges = graph.findBridgeWords(word1, word2);
        if (bridges == null || bridges.isEmpty()) {
            return "No bridge words from \"" + word1 + "\" to \"" + word2 + "\"!";
        }
        
        if (bridges.size() == 1) {
            return "The bridge word from \"" + word1 + "\" to \"" + word2 + "\" is: \"" + bridges.get(0) + "\"";
        }
        
        return "The bridge words from \"" + word1 + "\" to \"" + word2 + "\" are: \"" +
                String.join(", \"", bridges.subList(0, bridges.size() - 1)) +
                "\" and \"" + bridges.get(bridges.size() - 1) + "\"";
    }

    public static String generateNewText(String inputText) {
        List<String> words = Arrays.stream(inputText.replaceAll("[^a-zA-Z\\s]", " ")
                .toLowerCase().split("\\s+"))
                .filter(s -> !s.isEmpty())
                .toList();
        List<String> result = new ArrayList<>();

        for (int i = 0; i < words.size(); i++) {
            result.add(words.get(i));
            if (i < words.size() - 1) {
                List<String> bridges = graph.findBridgeWords(words.get(i), words.get(i + 1));
                if (bridges != null && !bridges.isEmpty()) {
                    result.add(bridges.get(new Random().nextInt(bridges.size())));
                }
            }
        }
        return String.join(" ", result);
    }

    public static String calcShortestPath(String word1, String word2) {
        List<String> path = graph.calcShortestPath(word1, word2);
        if (path == null) return "No path exists between \"" + word1 + "\" and \"" + word2 + "\"";
        int length = 0;
        for (int i = 0; i < path.size() - 1; i++) {
            length += graph.getEdges(path.get(i)).get(path.get(i + 1));
        }
        return "Path: " + String.join(" -> ", path) + "\nLength: " + length;
    }

    public static Double calcPageRank(String word) {
        return graph.calculatePageRank(100).getOrDefault(word, 0.0);
    }

    public static String randomWalk() {
        return graph.randomWalk();
    }
}
</Code>

请评估项目代码（安全性，代码风格，实现性能等）。